<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cool Places · Clarence Yeung</title>
    <link rel="stylesheet" href="style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <nav class="globe-nav">
      <a href="index.html">← Back to home</a>
    </nav>

    <!-- Layout Wrapper -->
    <main class="page globe-page">
      <div class="globe-intro">
        <p>I've been extremely fortunate to bike and ride in some of the most beautiful places in the world. Hover over each pin to see where I've explored.</p>
      </div>
      <!-- Visual Placeholder Column -->
      <section class="visual-column">
        <div class="visual-container" role="presentation">
          <div class="visual-stage" id="globe-stage" aria-hidden="true"></div>
          <div
            class="visual-tooltip"
            id="globe-tooltip"
            role="status"
            aria-live="polite"
            hidden
          ></div>
        </div>
        <div id="globe-legend" aria-label="Legend" hidden></div>
      </section>
    </main>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      /* ---------------------------------------- */
      /* Minimal Globe Setup                      */
      /* ---------------------------------------- */
      const stage = document.getElementById('globe-stage');
      const tooltip = document.getElementById('globe-tooltip');

      const globeScene = new THREE.Scene();
      const globeCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
      const globeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      globeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globeRenderer.outputColorSpace = THREE.SRGBColorSpace;
      globeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      globeRenderer.toneMappingExposure = 1.05;
      globeRenderer.setClearColor(0x000000, 0);
      stage.appendChild(globeRenderer.domElement);
      globeRenderer.domElement.style.cursor = 'grab';
      globeRenderer.domElement.style.outline = 'none';
      globeRenderer.domElement.addEventListener('pointerdown', () => {
        globeRenderer.domElement.style.cursor = 'grabbing';
      });
      ['pointerup', 'pointerleave'].forEach((evt) => {
        globeRenderer.domElement.addEventListener(evt, () => {
          globeRenderer.domElement.style.cursor = 'grab';
        });
      });

      const globeGroup = new THREE.Group();
      globeScene.add(globeGroup);

      const globeRadius = 3.2;


      // Create canvas for country fill texture
      const canvasWidth = 4096;
      const canvasHeight = 2048;
      const countryCanvas = document.createElement('canvas');
      countryCanvas.width = canvasWidth;
      countryCanvas.height = canvasHeight;
      const ctx = countryCanvas.getContext('2d');
      
      // Set background to transparent
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      // Country fill color
      const countryColor = '#636B2F';

      const markerGroup = new THREE.Group();
      globeGroup.add(markerGroup);

      const ambientLight = new THREE.AmbientLight(0xf5f4ed, 0.6);
      globeScene.add(ambientLight);
      const sunLight = new THREE.DirectionalLight(0xffffff, 0.85);
      sunLight.position.set(-6.5, 7.5, 6.5);
      globeScene.add(sunLight);

      globeCamera.position.set(0, 0, globeRadius * 4.2);

      const controls = new OrbitControls(globeCamera, globeRenderer.domElement);
      controls.enablePan = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enableZoom = true;
      controls.minDistance = globeRadius * 1.6;
      controls.maxDistance = globeRadius * 4.8;

      let userIsInteracting = false;
      controls.addEventListener('start', () => {
        userIsInteracting = true;
      });
      controls.addEventListener('end', () => {
        userIsInteracting = false;
      });

      globeGroup.rotation.x = THREE.MathUtils.degToRad(18);

      // Convert lat/lon to 3D Vector3 on sphere surface
      const latLonToVector3 = (lat, lon, radius) => {
        const phi = (90 - lat) * Math.PI / 180;
        const theta = (lon + 180) * Math.PI / 180;
        return new THREE.Vector3(
          -radius * Math.sin(phi) * Math.cos(theta),
          radius * Math.cos(phi),
          radius * Math.sin(phi) * Math.sin(theta)
        );
      };

      // Keep convertLatLonToXYZ for marker compatibility
      const convertLatLonToXYZ = (lat, lon, radius) => {
        return latLonToVector3(lat, lon, radius);
      };

      // Convert lat/lon to equirectangular UV coordinates for canvas
      const latLonToUV = (lat, lon) => {
        const u = ((lon + 180) / 360) * canvasWidth;
        const v = ((90 - lat) / 180) * canvasHeight;
        return { u, v };
      };

      // Draw a polygon ring on the canvas
      const drawPolygonOnCanvas = (rings) => {
        if (!Array.isArray(rings) || rings.length === 0) return;
        const [outer, ...holes] = rings;
        if (!outer || outer.length < 2) return;

        ctx.beginPath();
        
        // Draw outer ring
        const firstPoint = latLonToUV(outer[0][1], outer[0][0]);
        ctx.moveTo(firstPoint.u, firstPoint.v);
        
        for (let i = 1; i < outer.length; i++) {
          const point = latLonToUV(outer[i][1], outer[i][0]);
          ctx.lineTo(point.u, point.v);
        }
        
        // Close the path
        ctx.closePath();
        
        // Draw holes (subtract from fill)
        for (const hole of holes) {
          if (!Array.isArray(hole) || hole.length < 2) continue;
          const firstHolePoint = latLonToUV(hole[0][1], hole[0][0]);
          ctx.moveTo(firstHolePoint.u, firstHolePoint.v);
          
          for (let i = 1; i < hole.length; i++) {
            const point = latLonToUV(hole[i][1], hole[i][0]);
            ctx.lineTo(point.u, point.v);
          }
          
          ctx.closePath();
        }
        
        // Fill the polygon
        ctx.fillStyle = countryColor;
        ctx.fill('evenodd'); // Use even-odd rule to handle holes correctly
      };

      // Load and render country boundaries as polylines and fill texture
      const loadCountryBoundaries = async () => {
        try {
          const response = await fetch(
            'https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson'
          );
          if (!response.ok) throw new Error('Failed to load country boundaries GeoJSON');
          const data = await response.json();
          const features = Array.isArray(data.features) ? data.features : [];
          
          // First pass: Draw all polygons on canvas
          features.forEach((feature) => {
            const geometry = feature && feature.geometry;
            if (!geometry) return;
            
            if (geometry.type === 'Polygon') {
              drawPolygonOnCanvas(geometry.coordinates);
            } else if (geometry.type === 'MultiPolygon') {
              // MultiPolygon is an array of Polygons
              geometry.coordinates.forEach((polygon) => {
                drawPolygonOnCanvas(polygon);
              });
            }
          });
          
          // Create texture from canvas
          const countryTexture = new THREE.CanvasTexture(countryCanvas);
          countryTexture.wrapS = THREE.ClampToEdgeWrapping;
          countryTexture.wrapT = THREE.ClampToEdgeWrapping;
          countryTexture.needsUpdate = true;
          
          // Create ocean material with country texture as emissive map
          const oceanMaterial = new THREE.MeshStandardMaterial({
            color: '#C7E6F4',
            emissive: new THREE.Color(countryColor),
            emissiveMap: countryTexture,
            emissiveIntensity: 0.6,
          });
          
          const oceanMesh = new THREE.Mesh(
            new THREE.SphereGeometry(globeRadius, 128, 128),
            oceanMaterial
          );
          globeGroup.add(oceanMesh);
        } catch (error) {
          console.error('Unable to load country boundaries', error);
        }
      };

      loadCountryBoundaries();

      const markerMeshes = [];
      let hoveredMarker = null;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const geocodeCache = new Map();

      const reverseGeocode = async (lat, lon) => {
        const key = `${lat.toFixed(3)},${lon.toFixed(3)}`;
        if (geocodeCache.has(key)) return geocodeCache.get(key);
        try {
          const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`;
          const res = await fetch(url, { headers: { 'Accept-Language': 'en' } });
          if (!res.ok) throw new Error('geocode failed');
          const data = await res.json();
          const addr = data && data.address ? data.address : {};
          const city = addr.city || addr.town || addr.village || addr.hamlet || addr.state_district || addr.state;
          const country = addr.country || '';
          const label = [city, country].filter(Boolean).join(', ') || 'Unknown location';
          geocodeCache.set(key, label);
          return label;
        } catch (e) {
          const fallback = 'Unknown location';
          geocodeCache.set(key, fallback);
          return fallback;
        }
      };

      const typeColors = {
        Ride: '#B08D28',          // mustard
        Run: '#8A5A44',           // warm rust
        Walk: '#6C7A3F',          // olive green
        Hike: '#4E6E5D',          // deep sage
        Swim: '#3B6C7A',          // teal
      };

      const createMarker = (activity) => {
        const { name, id, coordinates } = activity;
        if (!Array.isArray(coordinates) || coordinates.length < 2 || coordinates[0] == null || coordinates[1] == null) {
          return;
        }
        const colorHex = typeColors[activity.type] || '#B08D28';
        const lat = Number(coordinates[0]);
        const lon = Number(coordinates[1]);
        const position = convertLatLonToXYZ(lat, lon, globeRadius + 0.02);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color(colorHex),
          emissive: new THREE.Color(colorHex),
          emissiveIntensity: 0.25,
          transparent: true,
          opacity: 0.9,
          roughness: 0.45,
          metalness: 0.08,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.03, 16, 16), material);
        mesh.position.copy(position);
        mesh.lookAt(new THREE.Vector3(0, 0, 0));
        mesh.userData = {
          id,
          name,
          type: activity.type,
          lat,
          lon,
          baseEmissive: material.emissiveIntensity,
          baseOpacity: material.opacity,
        };
        markerGroup.add(mesh);
        markerMeshes.push(mesh);
      };

      const resetHover = () => {
        if (!hoveredMarker) return;
        hoveredMarker.material.emissiveIntensity = hoveredMarker.userData.baseEmissive;
        hoveredMarker.material.opacity = hoveredMarker.userData.baseOpacity;
        hoveredMarker.scale.set(1, 1, 1);
        hoveredMarker = null;
        tooltip.hidden = true;
        // resume gentle spin when no marker is hovered
        userIsInteracting = false;
      };

      const setHover = async (marker, event) => {
        if (hoveredMarker !== marker) {
          resetHover();
          hoveredMarker = marker;
          marker.material.emissiveIntensity = 0.35;
          marker.material.opacity = 0.95;
          marker.scale.set(1.45, 1.45, 1.45);
          tooltip.textContent = 'Loading…';
          tooltip.hidden = false;
          const label = await reverseGeocode(marker.userData.lat, marker.userData.lon);
          if (hoveredMarker === marker) {
            tooltip.textContent = label;
          }
        }
        // pause globe rotation while hovering a marker
        userIsInteracting = true;
        const rect = globeRenderer.domElement.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - rect.left + 12}px`;
        tooltip.style.top = `${event.clientY - rect.top - 12}px`;
      };

      const onMarkerClick = (marker) => {
        const { id, lat, lon } = marker.userData;
        const url = `https://www.google.com/maps/search/?api=1&query=${lat.toFixed(5)},${lon.toFixed(5)}`;
        window.open(url, '_blank', 'noopener');
        if (typeof window.onGlobeMarkerClick === 'function') {
          window.onGlobeMarkerClick({ id, lat, lon });
        }
      };

      const updatePointerFromEvent = (event) => {
        const rect = globeRenderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      };

      const handlePointerMove = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          setHover(intersects[0].object, event);
        } else {
          resetHover();
        }
      };

      const handlePointerLeave = () => {
        resetHover();
      };

      const handlePointerClick = (event) => {
        updatePointerFromEvent(event);
        raycaster.setFromCamera(pointer, globeCamera);
        const intersects = raycaster.intersectObjects(markerMeshes);
        if (intersects.length > 0) {
          const marker = intersects[0].object;
          onMarkerClick(marker);
        }
      };

      globeRenderer.domElement.addEventListener('pointermove', handlePointerMove);
      globeRenderer.domElement.addEventListener('pointerleave', handlePointerLeave);
      globeRenderer.domElement.addEventListener('click', handlePointerClick);

      const resizeGlobe = () => {
        const { clientWidth, clientHeight } = stage;
        if (!clientWidth || !clientHeight) return;
        globeRenderer.setSize(clientWidth, clientHeight, false);
        globeCamera.aspect = clientWidth / clientHeight;
        globeCamera.updateProjectionMatrix();
      };

      const loadActivities = async () => {
        try {
          const response = await fetch('assets/activities_visualization.json');
          if (!response.ok) throw new Error('Failed to load activities');
          const data = await response.json();
          resetHover();
          markerGroup.clear();
          markerMeshes.length = 0;
          const activities = (data.activities || []).filter((a) => a && a.type !== 'VirtualRide');
          activities.forEach(createMarker);
          // Build legend from present activity types
          const legendEl = document.getElementById('globe-legend');
          const presentTypes = Array.from(new Set(activities.map((a) => a.type).filter(Boolean)));
          legendEl.innerHTML = presentTypes
            .map((t) => {
              const c = typeColors[t] || '#B08D28';
              return `<div class="legend-item"><span class="legend-swatch" style="background:${c}"></span>${t}</div>`;
            })
            .join('');
          legendEl.hidden = presentTypes.length === 0;
        } catch (error) {
          console.warn(error);
        }
      };

      const animateGlobe = () => {
        requestAnimationFrame(animateGlobe);
        if (!userIsInteracting) {
          globeGroup.rotation.y += 0.00105;
        }
        controls.update();
        globeRenderer.render(globeScene, globeCamera);
      };

      resizeGlobe();
      window.addEventListener('resize', resizeGlobe);
      loadActivities();
      animateGlobe();
    </script>
  </body>
</html>
